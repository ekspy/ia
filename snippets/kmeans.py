# -*- coding: utf-8 -*-
"""AlgoritmoKMeans-Cluster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d7LLKMUUu00oI60VKLiWLqn3qvmo1Zxp

O algoritmo K-Means é um dos métodos de agrupamento (clustering) não supervisionado mais populares.

Ele busca dividir um conjunto de dados em k grupos (clusters), de forma que os pontos dentro de cada grupo sejam os mais semelhantes possíveis entre si e os mais diferentes possíveis dos pontos dos outros grupos.

O critério mais comum de semelhança é a distância euclidiana.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

clientes = {
    'cliente_id': [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],
    'tempo_na_loja': [10, 45, 30, 20, 60, 15, 50, 40, 25, 35],  # em minutos
    'valor_medio_compra': [20, 200, 150, 50, 300, 25, 250, 180, 60, 100],  # em reais
    'visitas_mensais': [1, 5, 4, 2, 6, 1, 5, 4, 2, 3]  # visitas por mês
}

df = pd.DataFrame(clientes)

X = df[['tempo_na_loja', 'valor_medio_compra', 'visitas_mensais']]

kmeans = KMeans(n_clusters=2, random_state=42)

df['cluster'] = kmeans.fit_predict(X)

print("Centróides dos clusters:")
print(kmeans.cluster_centers_)

print("\nClientes com seus respectivos clusters:")
print(df)

plt.figure(figsize=(8, 6))

plt.scatter(df['tempo_na_loja'], df['valor_medio_compra'],
            c=df['cluster'], cmap='viridis', s=100)

centroids = kmeans.cluster_centers_
plt.scatter(centroids[:, 0], centroids[:, 1],
            c='red', s=200, marker='X', label='Centróides')

plt.title("Clusters de Clientes com K-Means")
plt.xlabel("Tempo na Loja (min)")
plt.ylabel("Valor Médio da Compra (R$)")
plt.legend()
plt.grid(True)
plt.show()

"""# Escolha dos clusters - Métodos

*Método do Cotovelo (Elbow Method)*

Esse é o mais conhecido. Ele se baseia na análise da inércia (soma das distâncias dos pontos ao seu centróide). A ideia é:

Calcular a inércia para vários valores de k (ex: 1 a 10).

Plotar k no eixo x e a inércia no eixo y.

Procurar o ponto em que a inércia para de diminuir significativamente (o “cotovelo”).
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

dados = {
    'cliente_id': [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],
    'tempo_na_loja': [10, 45, 30, 20, 60, 15, 50, 40, 25, 35],  # em minutos
    'valor_medio_compra': [20, 200, 150, 50, 300, 25, 250, 180, 60, 100],  # em reais
    'visitas_mensais': [1, 5, 4, 2, 6, 1, 5, 4, 2, 3]  # visitas por mês
}
df = pd.DataFrame(dados)

X = df[['tempo_na_loja', 'valor_medio_compra']]

inercia = []

for k in range(1, 11):
    modelo = KMeans(n_clusters=k, random_state=42)
    modelo.fit(X)
    inercia.append(modelo.inertia_)

plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), inercia, marker='o')
plt.title('Método do Cotovelo')
plt.xlabel('Número de Clusters (k)')
plt.ylabel('Inércia')
plt.grid(True)
plt.show()

"""# Silhouette Score

Outra abordagem é calcular o índice de Silhouette, que mede o quão bem separado e coeso está cada cluster. Quanto mais próximo de 1, melhor.
"""

from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import matplotlib.pyplot as plt

silhouette_scores = []
k_values = list(range(2, 10))

for k in k_values:
    modelo = KMeans(n_clusters=k, random_state=42)
    labels = modelo.fit_predict(X)
    score = silhouette_score(X, labels)
    silhouette_scores.append(score)
    print(f'k={k}, Silhouette Score = {score:.4f}')

plt.figure(figsize=(8, 5))
plt.plot(k_values, silhouette_scores)
plt.title('Silhouette Score para diferentes valores de k')
plt.xlabel('Número de Clusters (k)')
plt.ylabel('Silhouette Score')
plt.grid(True)
plt.show()

"""# Métricas de Avaliação

Inérica:

Objetivo: quanto menor a inércia, mais compactos são os clusters.
"""

print(f"Inércia: {kmeans.inertia_}")

"""Análise do perfil dos clusters

Depois de criar os grupos, você pode descrever o perfil de cada grupo com médias, desvios e contagens:
"""

print(df.groupby('cluster').mean())